local player = game.Players.LocalPlayer
local WhitelistedUserIds = {
    7744772815
}

local isWhitelisted = false

print("Player ID:", player.UserId)

for _, userId in ipairs(WhitelistedUserIds) do
    print("Checking player ID:", player.UserId, "against whitelist ID:", userId)  -- Debugging log
    if tostring(player.UserId) == tostring(userId) then  -- Compare as strings
        isWhitelisted = true
        break
    end
end

if not isWhitelisted then
    print("Not whitelisted! Kicking the player.")
    player:Kick("Vilant V2 | Not whitelisted")
else
    print("User is whitelisted.")
end

local Library = loadstring(game:HttpGet('https://raw.githubusercontent.com/vilantvisuals/vilantui2/refs/heads/main/pc.lua'))()

local Window = Library:CreateWindow({

    Title = 'Vilant V2  |  Da Hood ðŸ¦†',
    Center = true,
    AutoShow = true,
    TabPadding = 8,
    MenuFadeTime = 0.4
})

local MainTab = Window:AddTab('            Main           ')
local Tabs = {
    Player = Window:AddTab('             Player          '),
    Visuals = Window:AddTab('             Visuals          '),
    Info = Window:AddTab('S'),
}

local MainTabbox = MainTab:AddLeftTabbox('Aimbot/camlock')
local AimbotTab = MainTabbox:AddTab('Aimbot')
local CamlockTab = MainTabbox:AddTab('Camlock')
local SilentTab = MainTabbox:AddTab('Silent aim')

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local MainEvent = ReplicatedStorage:WaitForChild("MainEvent")
local debris = game:GetService("Debris")
local CollectionService = game:GetService("CollectionService")
local StarterGui = game:GetService("StarterGui")
local TweenService = game:GetService("TweenService")

local targetHead, targetPlayer = nil, nil
local cursorLocked, orbitActive, aimbotEnabled = false, false, false
local orbitSpeed, radius, smoothness, predictionLevel = 10, 8, 0, 0
local currentKeybind = Enum.KeyCode.C

local function FindClosestPlayerHead()
    if not aimbotEnabled then return nil, nil end
    local closestPlayer, closestDistance = nil, math.huge
    local mousePosition = UserInputService:GetMouseLocation()

    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            local head = player.Character:FindFirstChild("Head")
            local humanoid = player.Character:FindFirstChild("Humanoid")
            local rootPart = player.Character:FindFirstChild("HumanoidRootPart")
            if head and humanoid and humanoid.Health > 0 and rootPart then
                local predictedPos = head.Position + (rootPart.AssemblyLinearVelocity * predictionLevel)
                local screenPoint, onScreen = Camera:WorldToViewportPoint(predictedPos)
                if onScreen then
                    local distance = (mousePosition - Vector2.new(screenPoint.X, screenPoint.Y)).Magnitude
                    if distance < closestDistance then
                        closestDistance, closestPlayer = distance, player
                    end
                end
            end
        end
    end
    return closestPlayer and closestPlayer.Character:FindFirstChild("Head"), closestPlayer
end

local function LockCursorToHead()
    if not aimbotEnabled then return end
    targetHead, targetPlayer = FindClosestPlayerHead()
    cursorLocked = targetHead ~= nil
end

local function UnlockCursor()
    cursorLocked, targetHead, targetPlayer = false, nil, nil
end

RunService.Stepped:Connect(function(deltaTime)
    if aimbotEnabled and cursorLocked and targetHead then
        local rootPart = targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart")
        if rootPart then
            local predictedPos = targetHead.Position + (rootPart.AssemblyLinearVelocity * predictionLevel)
            Camera.CFrame = Camera.CFrame:Lerp(CFrame.new(Camera.CFrame.Position, predictedPos), 1 - math.max(smoothness, 0.01))
        end
    end
    
    if aimbotEnabled and orbitActive and targetPlayer and targetPlayer.Character then
        local rootPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
        if rootPart then
            local angle = tick() * orbitSpeed
            local offset = Vector3.new(math.cos(angle) * radius, 0, math.sin(angle) * radius)
            LocalPlayer.Character:SetPrimaryPartCFrame(CFrame.new(rootPart.Position + offset))
        end
    end
end)

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed or not aimbotEnabled then return end
    if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == currentKeybind then
        if cursorLocked then UnlockCursor() else LockCursorToHead() end
    end
end)

AimbotTab:AddToggle('Aimbot', {
    Text = 'Enable', Default = false,
    Callback = function(Value) aimbotEnabled = Value end
})

AimbotTab:AddToggle('OrbitFeature', {
    Text = 'Target Strafe', Default = false,
    Callback = function(Value) orbitActive = Value end
})

AimbotTab:AddLabel('Keybind'):AddKeyPicker('KeyPicker', {
    Default = '', Mode = 'Toggle', Text = 'Aimbot',
    ChangedCallback = function(New) currentKeybind = New end
})

AimbotTab:AddSlider('SmoothnessSlider', {
    Text = 'Smoothness', Default = smoothness, Min = 0, Max = 1, Rounding = 2,
    Callback = function(Value) smoothness = Value end
})

AimbotTab:AddSlider('Strafe Speed', {
    Text = 'Strafe Speed', Default = orbitSpeed, Min = 0, Max = 100, Rounding = 1,
    Callback = function(Value) orbitSpeed = Value end
})

AimbotTab:AddSlider('PredictionSlider', {
    Text = 'Prediction', Default = predictionLevel, Min = 0, Max = 1, Rounding = 1,
    Callback = function(Value) predictionLevel = Value end
})

local camLockEnabled = false
local camLockTarget = nil
local camLockSmoothness = 1

CamlockTab:AddToggle('CamLockToggle', {
    Text = 'Enable',
    Default = false,
    Callback = function(state)
        camLockEnabled = state
        if not state then
            camLockTarget = nil
        end
    end,
}):AddKeyPicker('CamLockKeybind', {
    Default = '',
    Text = 'CamLock',
    Mode = 'Toggle',
    Callback = function()
        if UserInputService:GetFocusedTextBox() then return end
        if not camLockEnabled then return end

        if camLockTarget then
            camLockTarget = nil
        else
            local closestPlayer = nil
            local closestDistance = math.huge
            local mousePos = UserInputService:GetMouseLocation()

            for _, Player in pairs(Players:GetPlayers()) do
                if Player == LocalPlayer then continue end
                local character = Player.Character
                if character then
                    local HRP = character:FindFirstChild("Head")
                    if HRP then
                        local screenPos, onScreen = Camera:WorldToViewportPoint(HRP.Position)
                        if onScreen then
                            local distance = (Vector2.new(mousePos.X, mousePos.Y) - Vector2.new(screenPos.X, screenPos.Y)).Magnitude
                            if distance < closestDistance then
                                closestDistance = distance
                                closestPlayer = Player
                            end
                        end
                    end
                end
            end

            camLockTarget = closestPlayer
        end
    end,
})

RunService.RenderStepped:Connect(function()
    if camLockEnabled and camLockTarget then
        local character = camLockTarget.Character
        if character then
            local HRP = character:FindFirstChild("HumanoidRootPart")
            if HRP then
                local camera = workspace.CurrentCamera
                local targetPosition = HRP.Position
                local currentCFrame = camera.CFrame
                local lookVector = (targetPosition - currentCFrame.Position).Unit
                local currentLookVector = currentCFrame.LookVector
                local smoothedLookVector = currentLookVector:Lerp(lookVector, camLockSmoothness)
                camera.CFrame = CFrame.new(currentCFrame.Position, currentCFrame.Position + smoothedLookVector)
            end
        end
    end
end)

local LeftGroupBox = MainTab:AddLeftGroupbox('                    Triggerbot')

local lp = Players.LocalPlayer or Players:GetPropertyChangedSignal("LocalPlayer"):Wait() and Players.LocalPlayer
local mouse = lp:GetMouse()

local EnumKeyCode = Enum.KeyCode
local EnumUserInputType = Enum.UserInputType

local Script = {
    Functions = {},
    Table = {
        Start = {
            TriggerBot = {
                Keybind = "",
                Delay = 0.1,
                Blacklisted = {}
            }
        }
    },
    Connections = {}
}

Script.Functions.isDead = function(player)
    local character = player.Character
    if not character then return false end

    local bodyEffects = character:FindFirstChild("BodyEffects")
    if not bodyEffects then return false end

    local ko = bodyEffects:FindFirstChild("K.O") or bodyEffects:FindFirstChild("KO")
    return ko and ko.Value or false
end

Script.Functions.getTarget = function(instance)
    if not instance then return false end

    for _, player in next, Players:GetPlayers() do
        if player.Character and instance:IsDescendantOf(player.Character) then
            if not Script.Functions.isDead(player) then
                return player
            end
        end
    end

    return false
end

Script.Functions.isToolBlacklisted = function(tool)
    for _, toolName in ipairs(Script.Table.Start.TriggerBot.Blacklisted) do
        if tool.Name == toolName then
            return true
        end
    end
    return false
end

local JAIROUGH = false
local hotkeyEnabled = false
local highlightEnabled = false
local lastHoveredPlayer = nil

Script.Functions.updateDelay = function(Value)
    Script.Table.Start.TriggerBot.Delay = Value
end

Script.Functions.onKeyPress = function(input, gameProcessed)
    if gameProcessed then return end

    if hotkeyEnabled and input.UserInputType == EnumUserInputType.Keyboard and input.KeyCode == Enum.KeyCode[Script.Table.Start.TriggerBot.Keybind] then
        JAIROUGH = not JAIROUGH
    end
end

Script.Functions.updateKeybind = function(NewKey)
    Script.Table.Start.TriggerBot.Keybind = NewKey.Name
end

UserInputService.InputBegan:Connect(Script.Functions.onKeyPress)

Script.Functions.highlightTarget = function(targetPlayer)
    if highlightEnabled and JAIROUGH then
        if lastHoveredPlayer and lastHoveredPlayer ~= targetPlayer then
            local oldCharacter = lastHoveredPlayer.Character
            if oldCharacter then
                local highlight = oldCharacter:FindFirstChild("ChamHighlight")
                if highlight then
                    highlight:Destroy()
                end
            end
        end

        if targetPlayer and targetPlayer.Character then
            local character = targetPlayer.Character
            if not character:FindFirstChild("ChamHighlight") then
                local highlight = Instance.new("Highlight")
                highlight.Name = "ChamHighlight"
                highlight.Parent = character
                highlight.Adornee = character
                highlight.FillColor = Color3.fromRGB(255, 0, 0)  
                highlight.FillTransparency = 0.5
                highlight.OutlineTransparency = 1
            end
            lastHoveredPlayer = targetPlayer  
        end
    else
        if lastHoveredPlayer and lastHoveredPlayer.Character then
            local highlight = lastHoveredPlayer.Character:FindFirstChild("ChamHighlight")
            if highlight then
                highlight:Destroy()
            end
        end
    end
end

Script.Functions.triggerBot = function()
    local con
    con = RunService.Heartbeat:Connect(function()
        if JAIROUGH then
            local target = mouse.Target
            local targetPlayer = Script.Functions.getTarget(target)
            Script.Functions.highlightTarget(targetPlayer)

            if targetPlayer and lp.Character then
                local tool = lp.Character:FindFirstChildWhichIsA('Tool')
                if tool and not Script.Functions.isToolBlacklisted(tool) then
                    task.wait(Script.Table.Start.TriggerBot.Delay)
                    tool:Activate()
                end
            end
        end
    end)

    Script.Connections.triggerBot = con
end

Script.Functions.triggerBot()

getgenv().disable = function()
    getgenv().disable = nil
    if Script.Connections.triggerBot then
        Script.Connections.triggerBot:Disconnect()
    end
end

LeftGroupBox:AddToggle('EnableTriggerBot', {
    Text = 'Enable',
    Default = false,
    Tooltip = 'Enable or Disable the hotkey for TriggerBot',
    Callback = function(Value)
        hotkeyEnabled = Value
        
        if not hotkeyEnabled then
            JAIROUGH = false
        end
    end
})

LeftGroupBox:AddToggle('HighlightToggle', {
    Text = 'Highlight',
    Default = false,
    Tooltip = 'Player highlight when triggerbot is active',
    Callback = function(Value)
        highlightEnabled = Value
    end
})

LeftGroupBox:AddLabel('Keybind'):AddKeyPicker('KeyPicker', {
    Default = Script.Table.Start.TriggerBot.Keybind,
    SyncToggleState = false,
    Mode = 'Toggle',
    Text = '',
    NoUI = false,
    ChangedCallback = function(New)
        Script.Functions.updateKeybind(New)
    end
})

LeftGroupBox:AddSlider('DelaySlider', {
    Text = 'Delay',
    Default = Script.Table.Start.TriggerBot.Delay,
    Min = 0,
    Max = 1,
    Rounding = 3,
    Compact = false,
    Callback = function(Value)
        Script.Functions.updateDelay(Value)
    end
})

RunService.Heartbeat:Connect(function()
    if highlightEnabled and JAIROUGH then
        local target = mouse.Target
        local targetPlayer = Script.Functions.getTarget(target)

        if targetPlayer then
            Script.Functions.highlightTarget(targetPlayer)
        elseif lastHoveredPlayer then
            Script.Functions.highlightTarget(nil)
        end
    elseif lastHoveredPlayer then
        Script.Functions.highlightTarget(nil)
    end
end)

local TargetingGroup = MainTab:AddLeftGroupbox('                    Shoot Gun')

local ReplicatedStorage = game:GetService('ReplicatedStorage')

local lockedTarget = nil
local StickyAimEnabled = false
local HighlightEnabled = false
local TracerEnabled = false
local ViewTargetEnabled = false
local targetHitPart = "Head"
local targetToMouseTracer = true
local grabCheckEnabled = true
local koCheckEnabled = true
local friendCheckEnabled = false
local predictMovementEnabled = false
local stompTargetEnabled = false
local lastPosition = nil
local oldPosition = nil
local Core = nil
local BodyVelocity = nil
local PredicTvalue = 1
local hiddenBulletsEnabled = false

local tracer = Drawing.new("Line")
tracer.Visible = false
tracer.Thickness = 1
tracer.Color = Color3.fromRGB(0, 0, 255)

function predictPosition(targetRoot, predictionMultiplier)
    if not targetRoot then return targetRoot.Position end
    if targetRoot.Velocity.Magnitude > 700 then
        return targetRoot.Position
    end
    return targetRoot.Position + (targetRoot.Velocity * predictionMultiplier)
end

TargetingGroup:AddToggle("StickyAim", {
    Text = "Enable",
    Default = false,
    Callback = function(Value)
        StickyAimEnabled = Value
        if not Value then
            lockedTarget = nil
            workspace.CurrentCamera.CameraSubject = game.Players.LocalPlayer.Character:FindFirstChild("Humanoid")
            targetHighlight.Enabled = false
            tracer.Visible = false
        end
    end
}):AddKeyPicker("StickyAimKeybind", {
    Default = "",
    NoUI = false,
    Text = "Enable",
    Mode = "Toggle",
    Callback = function()
        if game:GetService("UserInputService"):GetFocusedTextBox() then return end
        if lockedTarget then
            lockedTarget = nil
            workspace.CurrentCamera.CameraSubject = game.Players.LocalPlayer.Character:FindFirstChild("Humanoid")
            targetHighlight.Enabled = false
            tracer.Visible = false
        else
            local camera = workspace.CurrentCamera
            local mouseLocation = game:GetService("UserInputService"):GetMouseLocation()
            local closestTarget, closestDistance = nil, math.huge

            for _, otherPlayer in ipairs(game:GetService("Players"):GetPlayers()) do
                if otherPlayer ~= game.Players.LocalPlayer and otherPlayer.Character and otherPlayer.Character:FindFirstChild(targetHitPart) then
                    local bodyEffects = otherPlayer.Character:FindFirstChild("BodyEffects")
                    local isKO = bodyEffects and bodyEffects:FindFirstChild("K.O") and bodyEffects["K.O"].Value
                    local isGrabbed = otherPlayer.Character:FindFirstChild("GRABBING_CONSTRAINT")

                    if (not grabCheckEnabled or not isGrabbed) and
                       (not friendCheckEnabled or not game.Players.LocalPlayer:IsFriendsWith(otherPlayer.UserId)) then

                        local targetPart = otherPlayer.Character[targetHitPart]
                        local screenPosition, onScreen = camera:WorldToViewportPoint(targetPart.Position)
                        if onScreen then
                            local distance = (Vector2.new(screenPosition.X, screenPosition.Y) - mouseLocation).Magnitude
                            if distance < closestDistance then
                                closestTarget = otherPlayer
                                closestDistance = distance
                            end
                        end
                    end
                end
            end

            if closestTarget then
                lockedTarget = closestTarget
            end
        end
    end
})

TargetingGroup:AddToggle("ViewTarget", {
    Text = "View Target",
    Default = false,
    Callback = function(Value)
        ViewTargetEnabled = Value
        if not Value then
            workspace.CurrentCamera.CameraSubject = game.Players.LocalPlayer.Character:FindFirstChild("Humanoid")
        elseif lockedTarget then
            workspace.CurrentCamera.CameraSubject = lockedTarget.Character
        end
    end
})

TargetingGroup:AddToggle("StompTarget", {
    Text = "Auto Stomp",
    Default = false,
    Callback = function(Value)
        stompTargetEnabled = Value
    end
})

TargetingGroup:AddToggle("HiddenBullets", {
    Text = "Invisible Bullets",
    Default = false,
    Callback = function(Value)
        hiddenBulletsEnabled = Value
    end
})

TargetingGroup:AddDropdown("hp", {
    Text = "Hit Part",
    Values = {"Head", "HumanoidRootPart", "UpperTorso", "Left Arm", "Right Arm", "Left Leg", "Right Leg"},
    Default = "Head",
    Callback = function(Value)
        targetHitPart = Value
    end
})

local RightGroupBox = MainTab:AddRightGroupbox('               Hitbox Expander')

getgenv().haven = {
    hitbox_expander = {
        Enabled = false,
        ShowHitboxes = false,
        XSize = 1,
        YSize = 1,
        ZSize = 1,
        Transparency = 0.8,
        Color = Color3.fromRGB(0, 0, 255),
    }
}

local TrackedPlayers = {}

local function UpdateHitbox(player, enable)
    if player == LocalPlayer then return end
    
    local character = player.Character
    if character and character:FindFirstChild("HumanoidRootPart") then
        local hrp = character.HumanoidRootPart
        if enable then
            hrp.Size = Vector3.new(
                getgenv().haven.hitbox_expander.XSize, 
                getgenv().haven.hitbox_expander.YSize, 
                getgenv().haven.hitbox_expander.ZSize
            )
            hrp.Transparency = getgenv().haven.hitbox_expander.ShowHitboxes and getgenv().haven.hitbox_expander.Transparency or 1
            hrp.Material = Enum.Material.ForceField
            hrp.CanCollide = false
            hrp.Color = getgenv().haven.hitbox_expander.Color
        else
            hrp.Size = Vector3.new(2, 2, 1)
            hrp.Transparency = 1
            hrp.Material = Enum.Material.SmoothPlastic
            hrp.CanCollide = true
            hrp.Color = getgenv().haven.hitbox_expander.Color
        end
    end
end

local function ApplyHitboxExpander()
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            UpdateHitbox(player, getgenv().haven.hitbox_expander.Enabled)
        end
    end
end

local function TrackPlayers()
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and not TrackedPlayers[player] then
            TrackedPlayers[player] = player.CharacterAdded:Connect(function()
                if getgenv().haven.hitbox_expander.Enabled then
                    UpdateHitbox(player, true)
                end
            end)
        end
    end
end

Players.PlayerAdded:Connect(TrackPlayers)
Players.PlayerRemoving:Connect(function(player)
    if TrackedPlayers[player] then
        TrackedPlayers[player]:Disconnect()
        TrackedPlayers[player] = nil
    end
end)

TrackPlayers()

RightGroupBox:AddToggle('ExpandHitboxToggle', {
    Text = 'Enable Hitboxes',
    Default = false,
    Callback = function(Value)
        getgenv().haven.hitbox_expander.Enabled = Value
        ApplyHitboxExpander()
    end
}):AddKeyPicker('HitboxKeybind', {
    Default = '',
    Mode = 'Toggle',
    Text = '',
    NoUI = false,
    Callback = function(Value)
        getgenv().haven.hitbox_expander.Enabled = not getgenv().haven.hitbox_expander.Enabled
        ApplyHitboxExpander()
    end
})

RightGroupBox:AddToggle('ShowHitboxToggle', {
    Text = 'Show Hitboxes',
    Default = false,
    Callback = function(Value)
        getgenv().haven.hitbox_expander.ShowHitboxes = Value
        ApplyHitboxExpander()
    end
}):AddKeyPicker('ShowHitboxKeybind', {
    Default = '',
    Mode = 'Toggle',
    Text = '',
    NoUI = false,
    Callback = function(Value)
        getgenv().haven.hitbox_expander.ShowHitboxes = not getgenv().haven.hitbox_expander.ShowHitboxes
        ApplyHitboxExpander()
    end
})

RightGroupBox:AddSlider('XSizeSlider', {
    Text = 'size-X',
    Default = 1,
    Min = 1,
    Max = 30,
    Rounding = 1,
    Callback = function(Value)
        getgenv().haven.hitbox_expander.XSize = Value
        ApplyHitboxExpander()
    end
})

RightGroupBox:AddSlider('YSizeSlider', {
    Text = 'size-Y',
    Default = 1,
    Min = 1,
    Max = 30,
    Rounding = 1,
    Callback = function(Value)
        getgenv().haven.hitbox_expander.YSize = Value
        ApplyHitboxExpander()
    end
})

RightGroupBox:AddSlider('ZSizeSlider', {
    Text = 'size-Z',
    Default = 1,
    Min = 1,
    Max = 30,
    Rounding = 1,
    Callback = function(Value)
        getgenv().haven.hitbox_expander.ZSize = Value
        ApplyHitboxExpander()
    end
})

local KillAura = MainTab:AddRightGroupbox('                    Kill Aura')

KillAura:AddToggle('MyToggle', {
    Text = 'Enable',
    Default = false,
    Tooltip = 'Kills everyone in your way',
    Callback = function(Value)
        if Value then
            player = game:GetService("Players").LocalPlayer
            runService = game:GetService("RunService")
            workspace = game:GetService("Workspace")
            range = 100
            killAuraEnabled = true
            local lastTarget = nil

            function isGunEquipped()
                local character = player.Character
                if character then
                    local tool = character:FindFirstChildWhichIsA("Tool")
                    return tool and tool:FindFirstChild("Handle") ~= nil
                end
                return false
            end

            function isTargetValid(targetCharacter)
                if targetCharacter then
                    local bodyEffects = targetCharacter:FindFirstChild("BodyEffects")
                    local KOd = bodyEffects and bodyEffects:FindFirstChild("K.O") and bodyEffects["K.O"].Value
                    local Grabbed = targetCharacter:FindFirstChild("GRABBING_CONSTRAINT") ~= nil
                    return not KOd and not Grabbed
                end
                return false
            end

            function getNearestPlayer()
                local character = player.Character
                local rootPart = character and character:FindFirstChild("HumanoidRootPart")
                local nearestPlayer = nil
                local shortestDistance = range

                if rootPart then
                    for _, plr in pairs(game:GetService("Players"):GetPlayers()) do
                        if plr ~= player and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") and isTargetValid(plr.Character) then
                            local targetRootPart = plr.Character:FindFirstChild("HumanoidRootPart")
                            local distance = (targetRootPart.Position - rootPart.Position).Magnitude

                            if distance <= shortestDistance then
                                nearestPlayer = plr
                                shortestDistance = distance
                            end
                        end
                    end
                end
                return nearestPlayer
            end

            function highlightTarget(targetPlayer)
                if _G.highlightEnabled then  
                    if lastTarget and lastTarget ~= targetPlayer then
                        local oldCharacter = lastTarget.Character
                        if oldCharacter then
                            local highlight = oldCharacter:FindFirstChild("ChamHighlight")
                            if highlight then
                                highlight:Destroy()
                            end
                        end
                    end

                    if targetPlayer and targetPlayer.Character then
                        local character = targetPlayer.Character
                        if not character:FindFirstChild("ChamHighlight") then
                            local highlight = Instance.new("Highlight")
                            highlight.Name = "ChamHighlight"
                            highlight.Parent = character
                            highlight.Adornee = character
                            highlight.FillColor = Color3.fromRGB(255, 0, 0) 
                            highlight.FillTransparency = 0.5
                            highlight.OutlineTransparency = 1
                        end
                        lastTarget = targetPlayer 
                    end
                else
                    if lastTarget and lastTarget.Character then
                        local highlight = lastTarget.Character:FindFirstChild("ChamHighlight")
                        if highlight then
                            highlight:Destroy()
                        end
                    end
                end
            end

            function shootNearestPlayer()
                if not killAuraEnabled or not isGunEquipped() then
                    return
                end

                local character = player.Character
                local rootPart = character and character:FindFirstChild("HumanoidRootPart")
                local tool = character and character:FindFirstChildWhichIsA("Tool") or player.Backpack:FindFirstChildWhichIsA("Tool")
                local targetPlayer = getNearestPlayer()

                highlightTarget(targetPlayer) 

                if tool and tool:FindFirstChild("Handle") and rootPart and targetPlayer and targetPlayer.Character then
                    local targetHead = targetPlayer.Character:FindFirstChild("Head")
                    if targetHead then
                        local direction = (targetHead.Position - rootPart.Position).unit
                        game:GetService("ReplicatedStorage"):WaitForChild("MainEvent"):FireServer("ShootGun", tool.Handle, rootPart.Position, targetHead.Position, targetHead, direction)
                    end
                end
            end

            runService.Heartbeat:Connect(function()
                if killAuraEnabled then
                    shootNearestPlayer()
                end
            end)  
        else
            killAuraEnabled = false
            if lastTarget and lastTarget.Character then
                local highlight = lastTarget.Character:FindFirstChild("ChamHighlight")
                if highlight then
                    highlight:Destroy()
                end
            end
        end
    end
})

KillAura:AddToggle('HighlightToggle', {
    Text = 'Highlight',
    Default = false,
    Tooltip = 'Highlights the player about to be killed',
    Callback = function(Value)
        _G.highlightEnabled = Value
        if not _G.highlightEnabled then
            for _, plr in pairs(game:GetService("Players"):GetPlayers()) do
                if plr.Character then
                    local highlight = plr.Character:FindFirstChild("ChamHighlight")
                    if highlight then
                        highlight:Destroy()
                    end
                end
            end
        end
    end
})

local MiscGroupBox = MainTab:AddRightGroupbox('                     M-Misc')

local utility = {}
getgenv().config = { enable = false, delay = 0.01 }
getgenv().is_firing = false

utility.get_gun = function()
    for _, tool in next, game.Players.LocalPlayer.Character:GetChildren() do
        if tool:IsA("Tool") and tool:FindFirstChild("Ammo") then return tool end
    end
end

utility.rapid = function(tool)
    tool:Activate()
end

game:GetService("UserInputService").InputBegan:Connect(function(i)
    if i.UserInputType == Enum.UserInputType.MouseButton1 then
        local gun = utility.get_gun()
        if getgenv().config.enable and gun and not getgenv().is_firing then
            getgenv().is_firing = true
            while getgenv().is_firing and getgenv().config.enable do
                utility.rapid(gun)
                task.wait(getgenv().config.delay)
            end
        end
    end
end)

game:GetService("UserInputService").InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        getgenv().is_firing = false
    end
end)

MiscGroupBox:AddToggle('RapidFireToggle', {
    Text = 'Rapid Fire',
    Default = false,
    Tooltip = 'Enable or disable rapid fire',
    Callback = function(Value)
        getgenv().config.enable = Value
        if not Value then
            getgenv().is_firing = false
        end
    end
})

local function Recalculate(Character)
    if not Character or not Character:FindFirstChild("HumanoidRootPart") then
        return Vector3.zero
    end

    local RootPart = Character.HumanoidRootPart
    local InitialPos = RootPart.Position
    local InitialTick = tick()

    task.wait(0.03)

    if not Character or not Character:FindFirstChild("HumanoidRootPart") then
        return Vector3.zero
    end

    local NewPos = RootPart.Position
    local NewTick = tick()

    local DeltaTime = NewTick - InitialTick
    if DeltaTime <= 0 then return Vector3.zero end

    local Velocity = (NewPos - InitialPos) / DeltaTime

    return Velocity
end

MiscGroupBox:AddToggle('ResolverToggle', {
    Text = 'Resolver',
    Default = false,
    Tooltip = 'Enable or disable the velocity resolver',
    Callback = function(Value)
        getgenv().config.enable = Value
    end
})

game:GetService("RunService").Heartbeat:Connect(function()
    if getgenv().config.enable then
        for _, player in ipairs(game.Players:GetPlayers()) do
            if player.Character then
                local velocity = Recalculate(player.Character)
            end
        end
    end
end)

local function handleAutoReload()
    local tool = game.Players.LocalPlayer.Character:FindFirstChildWhichIsA("Tool")
    if tool and tool:FindFirstChild("Ammo") then
        local ammoValue = tool.Ammo.Value
        if ammoValue <= 0 then
            MainEvent:FireServer("Reload", tool)
        end
    end
end

local function setupSilentReload(Value)
    local character = game.Players.LocalPlayer.Character
    if character then
        local humanoid = character:FindFirstChild("Humanoid")
        if humanoid then
            if Value then
                for _, animationTrack in pairs(humanoid:GetPlayingAnimationTracks()) do
                    if animationTrack.Animation.AnimationId == "rbxassetid://2877910736" then
                        animationTrack:Stop()
                    end
                end
            end
        end
    end
end

MiscGroupBox:AddToggle('AutoReloadToggle', {
    Text = 'Auto Reload',
    Default = false,
    Tooltip = 'Reloads Automatically when 0 ammo',
    Callback = function(Value)
        _G.AutoReload = Value
    end
})

MiscGroupBox:AddToggle('SilentReloadToggle', {
    Text = 'Silent Reload',
    Default = false,
    Tooltip = 'Reloads Silently',
    Callback = function(Value)
        setupSilentReload(Value)
    end
})

local autoReloadConnection = game:GetService("RunService").Heartbeat:Connect(function()
    if _G.AutoReload then
        handleAutoReload()
    end
end)

game.Players.LocalPlayer.CharacterAdded:Connect(function()
    setupSilentReload(_G.SilentReload)
end)

local uhhh = Tabs.Player:AddLeftGroupbox('                    Movement')

uhhh:AddToggle('WalkSpeedToggle', {
    Text = 'Humanoid speed',
    Default = false,
    Callback = function(state)
        getgenv().walkSpeedEnabled = state
        if not state then getgenv().walkSpeedKeybindActive = false end
    end,
})

Toggles.WalkSpeedToggle:AddKeyPicker('WalkSpeedKeybind', {
    Default = '',
    Text = 'Speed Keybind',
    Mode = 'Toggle',
    Callback = function(state)
        if game:GetService("UserInputService"):GetFocusedTextBox() then return end
        if getgenv().walkSpeedEnabled then getgenv().walkSpeedKeybindActive = state end
    end,
})

uhhh:AddSlider('WalkSpeedSlider', {
    Text = 'Speed',
    Default = 16,
    Min = 16,
    Max = 500,
    Rounding = 0,
    Callback = function(value)
        getgenv().walkSpeed = value
    end,
})

game:GetService('RunService').RenderStepped:Connect(function()
    local player = game.Players.LocalPlayer
    local character = player.Character
    local humanoid = character and character:FindFirstChild('Humanoid')
    
    if not humanoid then return end

    local userInputService = game:GetService("UserInputService")
    local isSprinting = userInputService:IsKeyDown(Enum.KeyCode.LeftShift) or userInputService:IsKeyDown(Enum.KeyCode.RightShift)

    if getgenv().walkSpeedEnabled and getgenv().walkSpeedKeybindActive then
        humanoid.WalkSpeed = getgenv().walkSpeed
    elseif isSprinting then
        humanoid.WalkSpeed = 26
    else
        humanoid.WalkSpeed = 16
    end
end)

getgenv().cframeSpeedEnabled = false
getgenv().cframeSpeedKeybindActive = false
getgenv().cframeSpeedAmount = 150
getgenv().cframeSpeedKeybind = Enum.KeyCode.V

uhhh:AddToggle('CFrameSpeedToggle', {
    Text = 'CFrame Speed',
    Default = false,
    Tooltip = 'Toggles speed using CFrame',
    Callback = function(state)
        getgenv().cframeSpeedEnabled = state
        if not state then
            getgenv().cframeSpeedKeybindActive = false
        end
    end,
}):AddKeyPicker('CFrameSpeedKeybind', {
    Default = '',
    Text = 'Keybind',
    Mode = 'Toggle',
    Callback = function(state)
        if game:GetService("UserInputService"):GetFocusedTextBox() then return end
        getgenv().cframeSpeedKeybindActive = state
    end,
})

uhhh:AddSlider('CFrameSpeedSlider', {
    Text = 'Speed',
    Default = 150,
    Min = 16,
    Max = 1000,
    Rounding = 0,
    Callback = function(value)
        getgenv().cframeSpeedAmount = value
    end
})

local function hasCharacter(player)
    local character = player and player.Character
    return character and character:FindFirstChild("HumanoidRootPart", true) and character:FindFirstChild("Humanoid", true)
end

local function updateCframeSpeed(deltaTime)
    if getgenv().cframeSpeedEnabled and getgenv().cframeSpeedKeybindActive and hasCharacter(game.Players.LocalPlayer) then
        local character = game.Players.LocalPlayer.Character
        local hrp = character:FindFirstChild("HumanoidRootPart", true)
        local humanoid = character:FindFirstChild("Humanoid", true)
        local moveDirection = humanoid and humanoid.MoveDirection

        if hrp and moveDirection then
            local movement = moveDirection.Unit * getgenv().cframeSpeedAmount * deltaTime
            if movement.Magnitude > 0 then
                hrp.CFrame = hrp.CFrame + movement
            end
        end
    end
end

game:GetService("RunService").Heartbeat:Connect(updateCframeSpeed)

game:GetService("UserInputService").InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end

    if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == getgenv().cframeSpeedKeybind then
        if getgenv().cframeSpeedToggleAllowed then
            getgenv().cframeSpeedKeybindActive = not getgenv().cframeSpeedKeybindActive
        end
    end
end)

getgenv().rageCFrameFlyEnabled = false
getgenv().rageCFrameFlyKeybindActive = false
getgenv().rageCFrameFlyAmount = 250
getgenv().rageCFrameFlyKeybind = Enum.KeyCode.B

uhhh:AddToggle('CframeFlightToggle', {
    Text = 'Cframe Flight',
    Default = false,
    Tooltip = 'Toggles flight using CFrame',
    Callback = function(state)
        getgenv().rageCFrameFlyEnabled = state
        if not state then
            getgenv().rageCFrameFlyKeybindActive = false
        end
    end
}):AddKeyPicker('CframeFlyKeybind', {
    Default = '',
    Text = 'Keybind',
    Mode = 'Toggle',
    Callback = function(state)
        if game:GetService("UserInputService"):GetFocusedTextBox() then return end
        getgenv().rageCFrameFlyKeybindActive = state
    end,
})

uhhh:AddSlider('CframeFlightSpeed', {
    Text = 'Speed',
    Default = 250,
    Min = 16,
    Max = 2000,
    Rounding = 0,
    Callback = function(value)
        getgenv().rageCFrameFlyAmount = value
    end
})

local function updateFly(deltaTime)
    if getgenv().rageCFrameFlyEnabled and getgenv().rageCFrameFlyKeybindActive and hasCharacter(game.Players.LocalPlayer) then
        local character = game.Players.LocalPlayer.Character
        local hrp = character:FindFirstChild("HumanoidRootPart", true)
        local moveDirection = character:FindFirstChild("Humanoid", true).MoveDirection

        local verticalSpeed = (UserInputService:IsKeyDown(Enum.KeyCode.Space) and 1 or UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) and -1 or 0)
        local verticalMovement = Vector3.new(0, verticalSpeed, 0)

        local movement = (moveDirection + verticalMovement).Unit * getgenv().rageCFrameFlyAmount * deltaTime

        if movement.Magnitude > 0 then
            hrp.CFrame = hrp.CFrame + movement
        end

        hrp.Velocity = Vector3.zero
    end
end

game:GetService("RunService").Heartbeat:Connect(updateFly)

game:GetService("UserInputService").InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end

    if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == getgenv().rageCFrameFlyKeybind then
        if getgenv().rageCFrameFlyToggleAllowed then
            getgenv().rageCFrameFlyKeybindActive = not getgenv().rageCFrameFlyKeybindActive
        end
    end
end)

local AnimationSpeed = 1

local animation = Instance.new("Animation")
animation.AnimationId = "rbxassetid://10714340543"

local animationTrack
local isPlaying = false
local flossEnabled = false

local function loadAnimationTrack(character)
    local humanoid = character:WaitForChild("Humanoid")
    animationTrack = humanoid:LoadAnimation(animation)
    animationTrack.Looped = true
    animationTrack.Priority = Enum.AnimationPriority.Action
    
    if flossEnabled then
        task.wait(0.6)
        animationTrack:Play()
        animationTrack:AdjustSpeed(AnimationSpeed)
        isPlaying = true
    end
end

game:GetService("Players").LocalPlayer.CharacterAdded:Connect(function(character)
    loadAnimationTrack(character)
end)

if game:GetService("Players").LocalPlayer.Character then
    loadAnimationTrack(game:GetService("Players").LocalPlayer.Character)
end

uhhh:AddToggle("FlossToggle", {
    Text = "Floss",
    Default = false,
    Callback = function(state)
        flossEnabled = state
        if state and animationTrack then
            animationTrack:Play()
            animationTrack:AdjustSpeed(AnimationSpeed)
            isPlaying = true
        elseif not state and animationTrack then
            animationTrack:Stop()
            isPlaying = false
        end
    end
}):AddKeyPicker("FlossKeybindPicker", {
    Default = "",
    Text = "Floss",
    Mode = "Toggle",
    Callback = function(key)
        if UserInputService:GetFocusedTextBox() then return end
        if flossEnabled and animationTrack then
            if isPlaying then
                animationTrack:Stop()
            else
                animationTrack:Play()
                animationTrack:AdjustSpeed(AnimationSpeed)
            end
            isPlaying = not isPlaying
        end
    end
})

uhhh:AddToggle("NoClipToggle", {
    Text = "No Clip",
    Default = false,
    Callback = function(state)
        noClipEnabled = state
    end
}):AddKeyPicker("NoClipKeybindPicker", {
    Default = "",
    Text = "NoClip",
    Mode = "Toggle",
    Callback = function(state)
        if noClipEnabled then
            local character = game:GetService("Players").LocalPlayer.Character
            if character then
                for _, part in pairs(character:GetDescendants()) do
                    if part:IsA("BasePart") and not part.Name:match("Arm") and not part.Name:match("Leg") then
                        part.CanCollide = state
                    end
                end
            end
        end
    end
})

local function toggleNoJumpCooldown(enabled)
    local player = game.Players.LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()
    local humanoid = character:WaitForChild("Humanoid")

    local function updateJumpSettings(humanoid, state)
        humanoid.UseJumpPower = not state
    end

    updateJumpSettings(humanoid, enabled)

    player.CharacterAdded:Connect(function(newCharacter)
        local newHumanoid = newCharacter:WaitForChild("Humanoid")
        updateJumpSettings(newHumanoid, enabled)
    end)
end

uhhh:AddToggle('NoJumpCooldownToggle', {
    Text = 'Infinite Jump',
    Default = false,
    Callback = function(value)
        _G.noJumpCooldownEnabled = value
        toggleNoJumpCooldown(value)
    end
})

local LeftGroupBox = Tabs.Player:AddLeftGroupbox('                      Desync')

local Toggle = LeftGroupBox:AddToggle('AntiLock', {
    Text = 'Enable',
    Default = false,
    Tooltip = 'Desyncs so it\'s harder for players to hit you!', 

    Callback = function(Value)
        game:GetService("StarterGui"):SetCore("SendNotification", {
            Title = "Desync",
            Text = Value and "on" or "off",
            Duration = 1,
        })
    end
})

LeftGroupBox:AddDropdown('MyDropdown', {
    Values = { 'Nano sec teleport' },
    Default = 1,
    Multi = false, 
    Text = 'Mode',
    Tooltip = 'Teleports you in random positions every nano second',

    Callback = function(Value)
        print('[cb] Dropdown got changed. New value:', Value)
    end
})

RunService.Heartbeat:Connect(function()
    if Toggle.Value then
        local Character = LocalPlayer.Character
        if Character and Character:FindFirstChild("HumanoidRootPart") then
            local RootPart = Character.HumanoidRootPart
            local v = RootPart.Velocity
            RootPart.CFrame = RootPart.CFrame * CFrame.Angles(0, math.rad(0.01), 0)

            local randomVelocity = Vector3.new(
                math.random(-3000, 3000),
                math.random(-3000, 3000),
                math.random(-3000, 3000)
            )

            RootPart.Velocity = randomVelocity
            RunService.RenderStepped:Wait()
            RootPart.Velocity = v
        end
    end
end)

local LeftGroupBox = Tabs.Player:AddLeftGroupbox('                      Teleports')

local teleportLocations = {
    ["Bank"] = CFrame.new(-442, 39, -284),
    ["Inside Bank"] = CFrame.new(-443, 23, -284),
    ["Vault"] = CFrame.new(-658, -30, -285),
    ["Revolver"] = CFrame.new(-634, 21, -132),
    ["LMG"] = CFrame.new(-626, 23, -295),
    ["DownHill"] = CFrame.new(-559, 8, -735),
    ["Military Base"] = CFrame.new(-40, 65, -926),
    ["Uphill"] = CFrame.new(481, 48, -602),
    ["Police Station"] = CFrame.new(-264, 21, -93),
    ["School"] = CFrame.new(-594, 21, 173)
}

local locationKeys = {}
for name, _ in pairs(teleportLocations) do
    table.insert(locationKeys, name)
end

local selectedLocation = locationKeys[1]

LeftGroupBox:AddDropdown('TeleportDropdown', {
    Values = locationKeys,
    Default = 1,
    Multi = false,
    Text = 'Location',
    Tooltip = 'Choose a location to teleport to',
    Callback = function(Value)
        selectedLocation = Value
        print('Selected teleport location:', Value)
    end
})

LeftGroupBox:AddButton({
    Text = 'Teleport',
    Func = function()
        if game.Players.LocalPlayer.Character and teleportLocations[selectedLocation] then
            game.Players.LocalPlayer.Character:SetPrimaryPartCFrame(teleportLocations[selectedLocation])
            print('Teleported to:', selectedLocation)
        end
    end,
    DoubleClick = false,
    Tooltip = 'Teleports you to the selected location'
})

local animationBaseUrl = "http://www.roblox.com/asset/?id="

local animations = {
    R15 = {
        idle = animationBaseUrl .. "2510196951",
        walk = animationBaseUrl .. "2510202577",
        run = animationBaseUrl .. "2510198475",
        jump = animationBaseUrl .. "2510197830",
        climb = animationBaseUrl .. "2510192778",
        fall = animationBaseUrl .. "2510195892",
    },
    Custom = {
        idle = animationBaseUrl .. "782841498",
        walk = animationBaseUrl .. "616168032",
        run = animationBaseUrl .. "616163682",
        jump = animationBaseUrl .. "1083218792",
        climb = animationBaseUrl .. "1083439238",
        fall = animationBaseUrl .. "707829716",
    },
     Levitation = {
        idle = animationBaseUrl .. "616006778",
        jump = animationBaseUrl .. "616008936",
        fall = animationBaseUrl .. "616005863",
        walk = animationBaseUrl .. "616013216",
        run = animationBaseUrl .. "616010382",
        climb = animationBaseUrl .. "616003713",
    },
    Mage = {
        idle = animationBaseUrl .. "707742142",
        jump = animationBaseUrl .. "707853694",
        fall = animationBaseUrl .. "707829716",
        walk = animationBaseUrl .. "707897309",
        run = animationBaseUrl .. "707861613",
        climb = animationBaseUrl .. "707826056",
    },
    Ninja = {
        idle = animationBaseUrl .. "656117400",
        jump = animationBaseUrl .. "656117878",
        fall = animationBaseUrl .. "656115606",
        walk = animationBaseUrl .. "656121766",
        run = animationBaseUrl .. "656118852",
        climb = animationBaseUrl .. "656114359",
    },
    Stylish = {
        idle = animationBaseUrl .. "616136790",
        jump = animationBaseUrl .. "616139451",
        fall = animationBaseUrl .. "616134815",
        walk = animationBaseUrl .. "616146177",
        run = animationBaseUrl .. "616140816",
        climb = animationBaseUrl .. "616133594",
    },
    Superhero = {
        idle = animationBaseUrl .. "616111295",
        jump = animationBaseUrl .. "616115533",
        fall = animationBaseUrl .. "616108001",
        walk = animationBaseUrl .. "616122287",
        run = animationBaseUrl .. "616117076",
        climb = animationBaseUrl .. "616104706",
    },
    Toy = {
        idle = animationBaseUrl .. "782841498",
        jump = animationBaseUrl .. "782847020",
        fall = animationBaseUrl .. "782846423",
        walk = animationBaseUrl .. "782843345",
        run = animationBaseUrl .. "782842708",
        climb = animationBaseUrl .. "782843869",
    },
    Vampire = {
        idle = animationBaseUrl .. "1083445855",
        jump = animationBaseUrl .. "1083455352",
        fall = animationBaseUrl .. "1083443587",
        walk = animationBaseUrl .. "1083473930",
        run = animationBaseUrl .. "1083462077",
        climb = animationBaseUrl .. "1083439238",
    },
    Werewolf = {
        idle = animationBaseUrl .. "1083195517",
        jump = animationBaseUrl .. "1083218792",
        fall = animationBaseUrl .. "1083189019",
        walk = animationBaseUrl .. "1083178339",
        run = animationBaseUrl .. "1083216690",
        climb = animationBaseUrl .. "1083182000",
    },
    Zombie = {
        idle = animationBaseUrl .. "616158929",
        jump = animationBaseUrl .. "616161997",
        fall = animationBaseUrl .. "616157476",
        walk = animationBaseUrl .. "616168032",
        run = animationBaseUrl .. "616163682",
        climb = animationBaseUrl .. "616156119",
    },
}

local function applyAnimations(animate, preset)
    if animate and preset then
        if animate.idle and animate.idle:FindFirstChild("Animation1") then
            animate.idle.Animation1.AnimationId = preset.idle
        else
            warn("Idle animation or Animation1 not found")
        end
        
        if animate.walk and animate.walk:FindFirstChild("WalkAnim") then
            animate.walk.WalkAnim.AnimationId = preset.walk
        else
            warn("Walk animation or WalkAnim not found")
        end

        if animate.run and animate.run:FindFirstChild("RunAnim") then
            animate.run.RunAnim.AnimationId = preset.run
        else
            warn("Run animation or RunAnim not found")
        end

        if animate.jump and animate.jump:FindFirstChild("JumpAnim") then
            animate.jump.JumpAnim.AnimationId = preset.jump
        else
            warn("Jump animation or JumpAnim not found")
        end

        if animate.climb and animate.climb:FindFirstChild("ClimbAnim") then
            animate.climb.ClimbAnim.AnimationId = preset.climb
        else
            warn("Climb animation or ClimbAnim not found")
        end

        if animate.fall and animate.fall:FindFirstChild("FallAnim") then
            animate.fall.FallAnim.AnimationId = preset.fall
        else
            warn("Fall animation or FallAnim not found")
        end
    end
end

local function applySelectedAnimations(character)
    local animate = character:FindFirstChild("Animate")
    if animate then
        local selectedPreset = animations[currentAnimationPreset]
        applyAnimations(animate, selectedPreset)
    end
end

local LeftGroupBox = Tabs.Player:AddLeftGroupbox('               Player Animations')

LeftGroupBox:AddDropdown('AnimationSelector', {
    Values = {'R15', 'Custom', 'Levitation', 'Mage', 'Ninja', 'Stylish', 'Superhero', 'Toy', 'Vampire', 'Werewolf', 'Zombie',},
    Default = 1,
    Multi = false,

    Text = 'Animation',
    Tooltip = 'MUST RESET!!!',

    Callback = function(Value)
        currentAnimationPreset = Value
    end
})

local animationLoaded = false
local player = Players.LocalPlayer

if not player then
    warn("[Animation Error]: LocalPlayer not found!")
    return
end

local function applyAnimations()
    local character = player.Character
    if not character or not character.Parent then return end
    if animationLoaded then return end

    local animate = character:FindFirstChild("Animate")
    if not animate then 
        warn("[Animation Error]: Animate script missing!")
        return 
    end

    local success, err = pcall(function()
        applySelectedAnimations(character)
    end)

    if success then
        animationLoaded = true
    elseif not _G.AnimationErrorLogged then
        warn("[Animation Error]: " .. err)
        _G.AnimationErrorLogged = true
    end
end

local function onCharacterAdded(character)
    animationLoaded = false
    repeat task.wait() until character:FindFirstChild("HumanoidRootPart")
    applyAnimations()
end

player.CharacterAdded:Connect(onCharacterAdded)

if player.Character then
    task.spawn(function()
        onCharacterAdded(player.Character)
    end)
end

local function onCharacterAdded(character)
    animationLoaded = false
    repeat task.wait() until character:FindFirstChild("Humanoid") and character:FindFirstChild("HumanoidRootPart")
    applyAnimations()
end

player.CharacterAdded:Connect(onCharacterAdded)

if player.Character and player.Character:FindFirstChild("Humanoid") and player.Character:FindFirstChild("HumanoidRootPart") then
    applyAnimations()
else
    task.spawn(function()
        repeat task.wait() until player.Character and player.Character:FindFirstChild("Humanoid") and player.Character:FindFirstChild("HumanoidRootPart")
        applyAnimations()
    end)
end

local function onCharacterAdded(character)
    animationLoaded = false
    repeat task.wait() until character:FindFirstChild("HumanoidRootPart")
    applyAnimations()
end

player.CharacterAdded:Connect(onCharacterAdded)

if player.Character then
    task.spawn(function()
        onCharacterAdded(player.Character)
    end)
end

if player.CharacterAdded then
    player.CharacterAdded:Connect(function()
        animationLoaded = false
        task.wait(0.5)
        applyAnimations()
    end)
else
    warn("[Animation Error]: CharacterAdded event not found!")
end

task.spawn(function()
    task.wait(1)
    applyAnimations()
end)

local stutz = Tabs.Player:AddRightGroupbox('                     Character')

local antifling = nil
local lastChecked = 0
local checkInterval = 1

stutz:AddToggle("AntiflingToggle", {
    Text = "No Fling",
    Default = false,
    Callback = function(state)
        if state then
            antifling = game:GetService("RunService").Stepped:Connect(function(_, time)
                if time - lastChecked >= checkInterval then
                    lastChecked = time
                    for _, player in pairs(game:GetService("Players"):GetPlayers()) do
                        if player ~= game.Players.LocalPlayer and player.Character then
                            for _, v in pairs(player.Character:GetDescendants()) do
                                if v:IsA("BasePart") then
                                    v.CanCollide = false
                                end
                            end
                        end
                    end
                end
            end)
        else
            if antifling then
                antifling:Disconnect()
                antifling = nil
            end
        end
    end
})

local CollectionService = game:GetService("CollectionService")
local cachedSeats = {}

local function processSeat(seat, state)
    if seat:IsA("Seat") and not cachedSeats[seat] then
        cachedSeats[seat] = seat -- Cache the seat
    end
    if cachedSeats[seat] then
        seat.CanTouch = not state -- Prevents players from interacting with the seat
        if state then
            CollectionService:AddTag(seat, "NoSeat")
        else
            CollectionService:RemoveTag(seat, "NoSeat")
        end
    end
end

local function initializeSeats()
    for _, object in ipairs(workspace:GetDescendants()) do
        if object:IsA("Seat") then
            cachedSeats[object] = object
        end
    end
end

local function monitorNewSeats()
    workspace.DescendantAdded:Connect(function(descendant)
        if descendant:IsA("Seat") then
            processSeat(descendant, CollectionService:HasTag(descendant, "NoSeat"))
        end
    end)
end

initializeSeats()
monitorNewSeats()

stutz:AddToggle('NoSeatsToggle', {
    Text = 'No Seats',
    Default = false,
    Tooltip = 'Makes it so you cant sit down on anything',
    Callback = function(value)
        print('[cb] No-Seats Toggle changed to:', value)
        for seat, _ in pairs(cachedSeats) do
            if seat and seat:IsA("Seat") then
                seat.CanTouch = not value -- Properly disable seats
                if value then
                    CollectionService:AddTag(seat, "NoSeat")
                else
                    CollectionService:RemoveTag(seat, "NoSeat")
                end
            end
        end
    end
})

stutz:AddToggle('AutoDropCashToggle', {
    Text = 'Drop Cash',
    Default = false,
    Tooltip = 'Automatically drops cash',
    Callback = function(Value)
        local Player = game:GetService("Players").LocalPlayer
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local RunService = game:GetService("RunService")
        local MainScreenGui = Player.PlayerGui.MainScreenGui
        local MoneyText = MainScreenGui.MoneyText

        getgenv().moneyDropEnabled = getgenv().moneyDropEnabled or false 

        local function getMoneyAmount()
            local moneyText = MoneyText.Text:match("%$(%d[%,%d]*)") 
            if moneyText then
                local cleanedMoneyString = moneyText:gsub(",", "") 
                local amount = tonumber(cleanedMoneyString)
                return amount or 0
            else
                return 0
            end
        end

        local function dropMoney(amountToDrop)
            if amountToDrop > 0 then
                ReplicatedStorage.MainEvent:FireServer("DropMoney", tostring(amountToDrop))  -- Convert amount to string
            end
        end

        local function toggleMoneyDrop()
            getgenv().moneyDropEnabled = not getgenv().moneyDropEnabled
        end

        RunService.Heartbeat:Connect(function()
            if getgenv().moneyDropEnabled then
                local money = getMoneyAmount() 
                dropMoney(money < 15000 and money or 15000)
            end
        end)

        toggleMoneyDrop()
    end
})

local antiVoidEnabled = false
stutz:AddToggle('AntiVoidToggle', {
    Text = 'Anti Void',
    Default = false,
    Tooltip = 'Prevents falling into the void by teleporting up',
    Callback = function(Value)
        antiVoidEnabled = Value
        print('[cb] AntiVoidToggle changed to:', Value)
    end
})

local function antiVoidCheck()
    local player = game:GetService("Players").LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()
    local rootPart = character:WaitForChild("HumanoidRootPart")
    
    if antiVoidEnabled and rootPart and rootPart.Position.Y <= -150 then
        rootPart.CFrame = rootPart.CFrame + Vector3.new(0, 500, 0)
    end
end

RunService.Heartbeat:Connect(antiVoidCheck)

local antiStompEnabled = false

local HumanoidStateType = Enum.HumanoidStateType
local KOD = "K.O"
local GRABBING_CONSTRAINT = "GRABBING_CONSTRAINT"

stutz:AddToggle('MyToggle', {
    Text = 'Anti Stomp',
    Default = false,
    Tooltip = '',
    
    Callback = function(Value)
        antiStompEnabled = Value 
    end
})

RunService.Heartbeat:Connect(function()
    local character = player.Character
    if not character or not character.Parent then return end -- Ensure valid character

    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end -- Stop if no humanoid

    local bodyEffects = character:FindFirstChild("BodyEffects")
    local KOd = bodyEffects and bodyEffects:FindFirstChild(KOD) and bodyEffects[KOD].Value
    local Grabbed = character:FindFirstChild(GRABBING_CONSTRAINT) ~= nil

    if antiStompEnabled and (KOd or Grabbed) then
        task.spawn(function() -- Prevent lag spikes
            humanoid.PlatformStand = true
            humanoid.WalkSpeed = 0
            humanoid.JumpHeight = 0
            humanoid.Health = 0 

            for _, part in pairs(character:GetChildren()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end

            humanoid:SetStateEnabled(HumanoidStateType.Physics, false)
            humanoid:SetStateEnabled(HumanoidStateType.Seated, false)
            humanoid:SetStateEnabled(HumanoidStateType.Climbing, false)
            humanoid:SetStateEnabled(HumanoidStateType.Freefall, false)
            humanoid:SetStateEnabled(HumanoidStateType.Ragdoll, false)

            humanoid.MaxHealth = humanoid.Health

            if bodyEffects then
                bodyEffects:ClearAllChildren()
            end

            for _, part in pairs(character:GetChildren()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end

            player:LoadCharacter()
        end)
    end
end)

stutz:AddToggle('MyToggle', {
    Text = 'Infinite Zoom',
    Default = false,
    Tooltip = 'Lets you zoom out infinitely',

    Callback = function(Value)

        if _G.zoomInitialized == nil then
            _G.zoomInitialized = false
        end

        if Value and not _G.zoomInitialized then
            player.CameraMaxZoomDistance = math.huge

            _G.zoomInitialized = true
        elseif not Value and _G.zoomInitialized then
            player.CameraMaxZoomDistance = 30

            _G.zoomInitialized = false
        end
    end
})

MyButton = stutz:AddButton({
    Text = 'Redeem Codes',
    Func = function()
        local codes = {
            "SHRIMP",
            "VIP",
            "2025",
            "DACARNIVAL",
            "RUBY",
            "THANKSGIVING24",
            "HALLOWEEN2024",
            "pumpkins2023",
            "TRADEME!",
            "Beary",
            "ShortCake",
            "DAUP"
        }
        
        local successfulCodes = {}
        
        local function redeemCode(code)
            local args = {
                [1] = "EnterPromoCode",
                [2] = code
            }
        
            game:GetService("ReplicatedStorage").MainEvent:FireServer(unpack(args))
        
            local successIndicator = false
            game:GetService("ReplicatedStorage").MainEvent.OnClientEvent:Connect(function(response)
                if response == "CodeRedeemed" then  -- Adjust response check as per actual server logic
                    successIndicator = true
                end
            end)
        
            wait(4)
        
            if successIndicator then
                table.insert(successfulCodes, code)
            end
        
            print("Attempted to redeem code: " .. code)
        end
        
        for _, code in ipairs(codes) do
            redeemCode(code)
        end        
    end,
    DoubleClick = false,
    Tooltip = 'Redeems Active codes in the game'
})

local RightGroupBox = Tabs.Player:AddRightGroupbox('                     Detections')

RightGroupBox:AddToggle("AntiModToggle", {
    Text = "Anti Mod",
    Default = false,
    Callback = function(Value)
        antiModEnabled = Value
        Library:Notify(antiModEnabled and "Anti Mod Enabled" or "Anti Mod Disabled", 2)
        if antiModEnabled then task.spawn(detectModerators) end
    end
})

RightGroupBox:AddToggle("CheckModFriends", {
    Text = "Friend Check",
    Tooltip = "Detects if any player is friends with a Moderator",
    Default = false,
    Callback = function(Value)
        checkModFriendsEnabled = Value
        Library:Notify(checkModFriendsEnabled and "Check Mod Friends Enabled" or "Check Mod Friends Disabled", 2)
        if checkModFriendsEnabled then task.spawn(checkFriendsWithMods) end
    end
})

RightGroupBox:AddToggle("GroupCheck", {
    Text = "Group Check",
    Tooltip = "Detects if any player is in the restricted groups",
    Default = false,
    Callback = function(Value)
        groupCheckEnabled = Value
        Library:Notify(groupCheckEnabled and "Group Check Enabled" or "Group Check Disabled", 2)
        if groupCheckEnabled then task.spawn(detectModerators) end
    end
})

RightGroupBox:AddDropdown("AntiModMethod", {
    Values = {"Notify", "Kick"},
    Default = "Notify",
    Multi = false,
    Text = "Method",
    Callback = function(Value)
        antiModMethod = Value
        Library:Notify("Anti-Mod Method set to: " .. antiModMethod, 3)
    end
})

getgenv().PlayerInfo = Tabs.Player:AddRightGroupbox('                     Player Misc')

PlayerInfo:AddToggle('view', {
    Text = 'Spectate',
    Default = false,
    Callback = function(state)
        if state and getgenv().SelectedTarget then
            local targetPlayer = Players:FindFirstChild(getgenv().SelectedTarget)
            if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("Humanoid") then
                Camera.CameraSubject = targetPlayer.Character:FindFirstChild("Humanoid")
            end
        else
            if LocalPlayer and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
                Camera.CameraSubject = LocalPlayer.Character:FindFirstChild("Humanoid")
            end
        end
    end,
})

local function safeTeleport(targetPlayer)
    if LocalPlayer and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and
       targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
       
        LocalPlayer.Character.HumanoidRootPart.CFrame = targetPlayer.Character.HumanoidRootPart.CFrame
    end
end

-- Teleport Button
PlayerInfo:AddButton('Teleport', function()
    local targetPlayer = Players:FindFirstChild(getgenv().SelectedTarget)
    if targetPlayer then
        safeTeleport(targetPlayer)
    end
end)

getgenv().TargetDropdown = PlayerInfo:AddDropdown('yepyep', {
    SpecialType = 'Player',
    Text = 'Select a Player',
    Tooltip = 'Select a player to perform actions on.',
    Callback = function(value)
        getgenv().SelectedTarget = value
    end,
    Options = function()
        local playerNames = {}
        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= LocalPlayer then
                table.insert(playerNames, player.Name)
            end
        end
        return playerNames
    end
})

local RightGroupBox = Tabs.Player:AddRightGroupbox('                     Audio Player')  

local soundEnabled = false 
local soundVolume = 1
local soundList = {     
    ["No disrespect"] = 90317758270266,     
    ["The city of Memphis"] = 106172723805803,     
    ["Los Gangster  [inst]"] = 107558212312864,
    ["with my chest"] = 85096138905039,
    ["lucid dreams"] = 1837103530,
    ["jc wrld"] = 5410084938,
    ["2023 ah phonk"] = 15689451063,
    ["die with a smile"] = 80511230354401,
    ["sigma boy funk"] = 87459334689630
}

local selectedSound = soundList["with my chest"]

local currentSound = nil

local function getSoundKeys()
    local keys = {}
    for key, _ in pairs(soundList) do
        table.insert(keys, key)
    end
    return keys
end

RightGroupBox:AddToggle('EnableMusic', {     
    Text = 'Enable Music',     
    Default = false,     
    Tooltip = 'Turn the music system on/off',         
    Callback = function(Value)         
        soundEnabled = Value     
        if not soundEnabled and currentSound then
            currentSound:Stop()
            currentSound:Destroy()
            currentSound = nil
            print("Sound stopped as the toggle is off.")
        end
    end 
})  

RightGroupBox:AddDropdown('SoundDropdown', {     
    Values = getSoundKeys(),     
    Default = 1,     
    Multi = false,     
    Text = 'Select Sound',         
    Callback = function(Value)         
        selectedSound = soundList[Value]     
    end 
})  

RightGroupBox:AddSlider('VolumeSlider', {     
    Text = 'Sound Volume',     
    Default = soundVolume,     
    Min = 0,     
    Max = 5,     
    Rounding = 1,     
    Compact = false,     
    Callback = function(Value)         
        soundVolume = Value 
        print('[cb] Volume set to:', Value)
        if currentSound then
            currentSound.Volume = soundVolume
        end
    end 
})

RightGroupBox:AddButton({     
    Text = 'Play Music',     
    Func = function()         
        if soundEnabled then
            print("Sound Enabled: Attempting to play sound")

            if currentSound then
                currentSound:Stop()
                currentSound:Destroy()
            end

            currentSound = Instance.new("Sound")
            currentSound.SoundId = "rbxassetid://" .. selectedSound
            currentSound.Volume = soundVolume
            currentSound.Parent = game:GetService("SoundService") 

            currentSound:Play()

            currentSound.Ended:Connect(function()
                currentSound:Destroy()
                currentSound = nil
            end)
        else
            print("Sound is Disabled")
        end
    end,     
    Tooltip = 'Plays the selected sound' 
})

local LeftGroupBox = Tabs.Visuals:AddLeftGroupbox('                     ESP')

getgenv().espEnabled = false
getgenv().espColor = Color3.new(1, 1, 1)
getgenv().healthBarEnabled = false

local ESPObjects = {}
local Camera = workspace.CurrentCamera
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local function CreateESP(player)
    if ESPObjects[player] then return end

    local box = Drawing.new("Square")
    box.Thickness = 1
    box.Filled = false
    box.Color = getgenv().espColor
    box.Visible = false

    local healthBar = Drawing.new("Line")
    healthBar.Thickness = 2
    healthBar.Color = Color3.new(0, 1, 0)
    healthBar.Visible = false

    ESPObjects[player] = {
        Box = box,
        HealthBar = healthBar
    }
end

local function UpdateESP()
    local cameraCF = Camera.CFrame
    local cameraPos = cameraCF.Position

    for player, objects in pairs(ESPObjects) do
        local character = player.Character
        if character and character:FindFirstChild("HumanoidRootPart") and player ~= LocalPlayer and getgenv().espEnabled then
            local rootPart = character.HumanoidRootPart
            local humanoid = character:FindFirstChildOfClass("Humanoid")

            if humanoid and humanoid.Health > 0 then
                local rootPosition, onScreen = Camera:WorldToViewportPoint(rootPart.Position)

                if onScreen and (cameraPos - rootPart.Position).Magnitude < 1000 then  -- Only update if player is visible and within range
                    local headPosition = Camera:WorldToViewportPoint(rootPart.Position + Vector3.new(0, 3, 0))
                    local footPosition = Camera:WorldToViewportPoint(rootPart.Position - Vector3.new(0, 3, 0))

                    local boxHeight = math.abs(headPosition.Y - footPosition.Y)
                    local boxWidth = boxHeight / 1.3

                    objects.Box.Position = Vector2.new(rootPosition.X - boxWidth / 2.2, headPosition.Y)
                    objects.Box.Size = Vector2.new(boxWidth, boxHeight)
                    objects.Box.Color = getgenv().espColor
                    objects.Box.Visible = true

                    if getgenv().healthBarEnabled then
                        local healthRatio = humanoid.Health / humanoid.MaxHealth
                        objects.HealthBar.From = Vector2.new(rootPosition.X - boxWidth / 2.5 - 4, headPosition.Y + (boxHeight * (1 - healthRatio)))
                        objects.HealthBar.To = Vector2.new(rootPosition.X - boxWidth / 2.5 - 4, footPosition.Y)
                        objects.HealthBar.Color = Color3.new(1 - healthRatio, healthRatio, 0)
                        objects.HealthBar.Visible = true
                    else
                        objects.HealthBar.Visible = false
                    end
                else
                    objects.Box.Visible = false
                    objects.HealthBar.Visible = false
                end
            else
                objects.Box.Visible = false
                objects.HealthBar.Visible = false
            end
        else
            objects.Box.Visible = false
            objects.HealthBar.Visible = false
        end
    end
end

local function DestroyESP(player)
    if ESPObjects[player] then
        ESPObjects[player].Box:Remove()
        ESPObjects[player].HealthBar:Remove()
        ESPObjects[player] = nil
    end
end

Players.PlayerAdded:Connect(function(player)
    player.CharacterAdded:Connect(function()
        task.wait(0.5)
        CreateESP(player)
    end)
end)

Players.PlayerRemoving:Connect(DestroyESP)

for _, player in pairs(Players:GetPlayers()) do
    if player ~= LocalPlayer then
        CreateESP(player)
    end
end

RunService.RenderStepped:Connect(UpdateESP)

LeftGroupBox:AddToggle('ESP Toggle', {
    Text = 'Boxes',
    Default = false,
    Tooltip = 'Toggle the ESP boxes on/off',
    Callback = function(Value)
        getgenv().espEnabled = Value
        if not Value then
            for _, objects in pairs(ESPObjects) do
                objects.Box.Visible = false
                objects.HealthBar.Visible = false
            end
        end
    end
}):AddColorPicker('ESP Color', {
    Text = 'ESP Box Color',
    Default = Color3.fromRGB(255, 255, 255),
    Callback = function(Value)
        getgenv().espColor = Value
    end
})

LeftGroupBox:AddToggle('Health Bar Toggle', {
    Text = 'Health Bar',
    Default = false,
    Tooltip = 'Toggle the ESP health bars on/off',
    Callback = function(Value)
        getgenv().healthBarEnabled = Value
    end
})

getgenv().envt = Tabs.Visuals:AddLeftGroupbox("Ambience")
getgenv().Lighting = game:GetService("Lighting")

getgenv().DefaultFogStart = Lighting.FogStart
getgenv().DefaultFogEnd = Lighting.FogEnd
getgenv().DefaultFogColor = Lighting.FogColor
getgenv().DefaultAmbient = Lighting.Ambient
getgenv().DefaultTechnology = Lighting.Technology.Name

getgenv().FogModified = false
getgenv().AmbientModified = false

envt:AddToggle('FogToggle', {
    Text = 'Fog',
    Default = false,
    Callback = function(Value)
        if Value then
            Lighting.FogEnd = getgenv().FogEnd or DefaultFogEnd
            Lighting.FogStart = getgenv().FogStart or DefaultFogStart
            getgenv().FogModified = true  -- Track if fog settings are modified
        else
            Lighting.FogEnd = DefaultFogEnd
            Lighting.FogStart = DefaultFogStart
            Lighting.FogColor = DefaultFogColor
            getgenv().FogModified = false  -- Reset flag
        end
    end
}):AddColorPicker('FogColor', {
    Default = DefaultFogColor,
    Title = 'Fog Color',
    Callback = function(Value)
        Lighting.FogColor = Value
    end
})

envt:AddSlider('FogStart', {
    Text = 'Fog Start',
    Default = DefaultFogStart,
    Min = 0,
    Max = 1000,
    Rounding = 1,
    Callback = function(Value)
        getgenv().FogStart = Value
        Lighting.FogStart = Value
    end
})

envt:AddSlider('FogEnd', {
    Text = 'Fog End',
    Default = DefaultFogEnd,
    Min = 10,
    Max = 10000,
    Rounding = 1,
    Callback = function(Value)
        getgenv().FogEnd = Value
        Lighting.FogEnd = Value
    end
})

envt:AddToggle('AmbientToggle', {
    Text = 'Ambient',
    Default = false,
    Callback = function(Value)
        if Value then
            Lighting.Ambient = getgenv().AmbientColor or DefaultAmbient
            getgenv().AmbientModified = true
        else
            Lighting.Ambient = DefaultAmbient
            getgenv().AmbientModified = false
        end
    end
}):AddColorPicker('AmbientColor', {
    Default = DefaultAmbient,
    Title = 'Ambient Color',
    Callback = function(Value)
        getgenv().AmbientColor = Value
        Lighting.Ambient = Value
    end
})

function restoreDefaultLightingSettings()
    if not getgenv().FogModified then
        Lighting.FogStart = DefaultFogStart
        Lighting.FogEnd = DefaultFogEnd
        Lighting.FogColor = DefaultFogColor
    end
    
    if not getgenv().AmbientModified then
        Lighting.Ambient = DefaultAmbient
    end
end

local LeftGroupBox = Tabs.Info:AddLeftGroupbox('                       Info')

LeftGroupBox:AddLabel('Founder & Developer | @fazefr0')
LeftGroupBox:AddLabel('Silent aim works only on 90+ UNCs')

local MenuGroup = Tabs['Info']:AddLeftGroupbox('')

MenuGroup:AddButton('Unload', function() Library:Unload() end)

Library:SetWatermarkVisibility(true)

local FrameTimer = tick()
local FrameCounter = 0;
local FPS = 60;

local WatermarkConnection = game:GetService('RunService').RenderStepped:Connect(function()
    FrameCounter += 1;

    if (tick() - FrameTimer) >= 1 then
        FPS = FrameCounter;
        FrameTimer = tick();
        FrameCounter = 0;
    end;

    Library:SetWatermark(('Vilant V2 ðŸ¦† - tpg6 | %s fps | %s ms'):format(
        math.floor(FPS),
        math.floor(game:GetService('Stats').Network.ServerStatsItem['Data Ping']:GetValue())
    ));
end);
